import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root'
})
export class BlogService {

  blogs: any[] = []

  blogs_json: any[] = [
    {"title":"Introducción a la computación distribuidas","resume":"La computación distribuida es un modelo para resolver problemas de computación masiva utilizando un gran número de ordenadores organizados en clústeres incrustados en una infraestructura de telecomunicaciones distribuida.","content":"<h1>La computaci&oacute;n distribuida</h1>\n<p>La computaci&oacute;n distribuida es un modelo para resolver problemas de <a href=\"https://es.wikipedia.org/wiki/Computaci%C3%B3n\">computaci&oacute;n</a> masiva utilizando un gran n&uacute;mero de <a href=\"https://es.wikipedia.org/wiki/Computadora_electr%C3%B3nica\">ordenadores</a> organizados en <a href=\"https://es.wikipedia.org/wiki/Cluster_(inform%C3%A1tica)\">cl&uacute;steres</a> incrustados en una infraestructura de telecomunicaciones distribuida.</p>\n<p>La computaci&oacute;n distribuida es un modelo inform&aacute;tico que permite hacer grandes c&aacute;lculos utilizando miles de ordenadores de voluntarios. Este sistema se basa en repartir la informaci&oacute;n a trav&eacute;s de Internet mediante un software, previamente descargado por el usuario, a diferentes ordenadores, que van resolviendo los c&aacute;lculos y una vez tienen el resultado lo env&iacute;an al servidor. Este proyecto, casi siempre solidarios, reparten la informaci&oacute;n a procesar entre los miles de ordenadores voluntarios para poder alcanzar cuotas de procesamiento a menudo mayores que las de <a href=\"https://es.wikipedia.org/wiki/Superordenador\">superordenadores</a>.</p>\n<h2>Computaci&oacute;n Paralela</h2>\n<p>La&nbsp;<a href=\"https://es.wikipedia.org/wiki/Computaci%C3%B3n_paralela\" target=\"_blank\" rel=\"noopener\"><strong>computaci&oacute;n paralela</strong></a> es una forma de c&oacute;mputo en la que muchas&nbsp;instrucciones&nbsp;se ejecutan simult&aacute;neamente,<sup id=\"cite_ref-1\"></sup>​ operando sobre el principio de que problemas grandes, a menudo se pueden dividir en unos m&aacute;s peque&ntilde;os, que luego son resueltos simult&aacute;neamente (en paralelo). Hay varias formas diferentes de computaci&oacute;n paralela: paralelismo a nivel de bit, paralelismo a nivel de instrucci&oacute;n, paralelismo de datos y paralelismo de tareas. El paralelismo se ha empleado durante muchos a&ntilde;os, sobre todo en la computaci&oacute;n de altas prestaciones, pero el inter&eacute;s en ella ha crecido &uacute;ltimamente debido a las limitaciones f&iacute;sicas que impiden el aumento de la frecuencia. <sup id=\"cite_ref-2\"></sup>​Como el consumo de energ&iacute;a y por consiguiente la generaci&oacute;n de calor de las computadoras constituye una preocupaci&oacute;n en los &uacute;ltimos a&ntilde;os,<sup id=\"cite_ref-4\"></sup>​ la computaci&oacute;n en paralelo se ha convertido en el paradigma dominante en la&nbsp;arquitectura de computadores, principalmente en forma de&nbsp;procesadores multin&uacute;cleo.<sup id=\"cite_ref-6\"></sup></p>\n<h2>Computaci&oacute;n Ubicua</h2>\n<p>La Computaci&oacute;n Ubicua, tambi&eacute;n denominada Computaci&oacute;n Pervasiva, fue descrita por primera vez por Mark Weiser en 1991. La esencia de su visi&oacute;n era la creaci&oacute;n de entornos repletos de computaci&oacute;n y capacidad de comunicaci&oacute;n, integrados de forma inapreciable con las personas. En la fecha en que Weiser describi&oacute; su idea no exist&iacute;a la tecnolog&iacute;a necesaria para llevarla a cabo, por lo que no era posible desarrollarla, pero despu&eacute;s de una d&eacute;cada de progreso, estas ideas son productos comercialmente viables, a&uacute;n cuando fueron en sus or&iacute;genes criticadas.</p>\n<p>Uno de los objetivos m&aacute;s importantes de la Computaci&oacute;n Ubicua es integrar los dispositivos computacionales lo m&aacute;s posible, como se puede ver en la figura, para hacer que se mezclen en la vida cotidiana, y permitir a los usuarios que se centren en las tareas que deben hacer, no en las herramientas que deben usar, pudiendo suponer una revoluci&oacute;n que cambie el modo de vida. El hecho de enviar la computaci&oacute;n a un &ldquo;segundo plano&rdquo; tiene dos significados:</p>\n<ul>\n<li>El primero es el significado literal, detallando que la tecnolog&iacute;a de la computaci&oacute;n se debe integrar en los objetos, cosas, tareas y entornos cotidianos.<!--[endif]--></li>\n<li>El segundo se refiere a que esta integraci&oacute;n se debe realizar de forma que estos elementos no deben interferir en las actividades para las que son usadas, proporcionando un uso m&aacute;s c&oacute;modo, sencillo y &uacute;til de los mismos.</li>\n</ul>\n<p><img src=\"https://lh6.googleusercontent.com/proxy/2U5z_l7Sdju_hTvb1kj2wo0sAnPrrb6UT8Yi0akgkE9kMpPlgssGVCJ88KeqfMKRASboJ3S_nPGZvlNwrq4YypUWkuwXLowqD67xbYBEEw=s0-d\" alt=\"\" width=\"512\" height=\"384\"></p>\n<p>Por tanto, los objetos cotidianos en los que se integra la tecnolog&iacute;a de computaci&oacute;n, tienen una serie de caracter&iacute;sticas que permiten y delimitan la creaci&oacute;n del entorno ubicuo buscado: Comunicaci&oacute;n entre dispositivos, ya que los elementos del sistema disponen no s&oacute;lo de capacidad de computaci&oacute;n, sino tambi&eacute;n de comunicaci&oacute;n, tanto con el usuario como con los dem&aacute;s elementos a su alrededor mediante WiFi, Bluetooth, GPRS/UMTS, UWB, RFID, etc.</p>\n<h3>Caracteristicas de computaci&oacute;n ubicua</h3>\n<ul>\n<li>Uso eficaz de espacios \"perspicaces\": Se basa, en la detecci&oacute;n del estado de un individuo y de sus necesidades, deducidas de dicho estado, ya sea en la oficina, sala de reuniones, clase, domicilio, coche, etc. El espacio perspicaz surge cuando varios dispositivos inteligentes coinciden en el mismo espacio f&iacute;sico e interact&uacute;an colaborativamente para dar soporte a los individuos que se encuentren en &eacute;l. La dom&oacute;tica, computaci&oacute;n ubicua en el domicilio, es la aplicaci&oacute;n m&aacute;s popular. &nbsp;</li>\n<li>Invisibilidad: Actualmente, se est&aacute; lejos de la propiedad expuesta por Weiser para los sistemas ubicuos, la completa desaparici&oacute;n de la tecnolog&iacute;a de la consciencia del usuario. Una buena aproximaci&oacute;n es tener presente, en el dise&ntilde;o de estos sistemas, la idea de m&iacute;nima distracci&oacute;n del usuario. La invisibilidad va a requerir del cambio dr&aacute;stico en el tipo de interfaces que nos comunican con los computadores. Reconocimiento de voz y de gestos, comprensi&oacute;n del lenguaje natural y del texto manuscrito, en la direcci&oacute;n hombre‐m&aacute;quina y en el sentido contrario, s&iacute;ntesis de lenguaje hablado y escrito y de representaciones gr&aacute;ficas. &nbsp;</li>\n<li>Escalabilidad local: El concepto de localidad de servicios en computaci&oacute;n ubicua es fundamental frente a la universalidad de servicios de Internet. Los usuarios disponen de capacidades asociadas al contexto en el que se encuentran, careciendo de sentido, por ejemplo, que las aplicaciones dom&oacute;ticas situadas en el domicilio particular tengan que estar escrutando las necesidades del usuario que se encuentra trabajando en ese momento en la oficina. Al igual que la mayor&iacute;a de las interacciones en la naturaleza, la proporcionada por estos sistemas, decrece con la distancia al usuario. &nbsp;</li>\n<li>Ocultaci&oacute;n de los desniveles de acondicionamiento: Dependiendo de la infraestructura y del desarrollo tecnol&oacute;gico disponible, la distribuci&oacute;n de los servicios ofrecidos puede ser muy poco uniforme, en esta situaci&oacute;n el principio de invisibilidad puede no cumplirse ya que el usuario detectar&iacute;a desagradables transiciones. Este requisito es hoy d&iacute;a el m&aacute;s alejado respecto de la situaci&oacute;n ideal, los sistemas que incorporan computaci&oacute;n ubicua est&aacute;n aislados, sin continuidad entre unos y otros.&nbsp;</li>\n</ul>\n<h3>Aplicaciones de la computaci&oacute;n ubicua</h3>\n<p>La Computaci&oacute;n Ubicua permite abarcar muy diversos campos:</p>\n<ul>\n<li>Almacenamiento de informaci&oacute;n</li>\n<li>Visualizaci&oacute;n de informaci&oacute;n</li>\n<li>Simulaci&oacute;n y realidad aumentada</li>\n<li>Construcci&oacute;n y modelado</li>\n<li>Gesti&oacute;n, configuraci&oacute;n y control de sistemas complejos</li>\n<li>Educaci&oacute;n</li>\n<li>Sistemas de programaci&oacute;n basados en el uso de objetos f&iacute;sicos para la codificaci&oacute;n de los algoritmos</li>\n<li>Trabajo colaborativo</li>\n<li>Entretenimiento</li>\n</ul>","date":"2022-05-20","autor":"","id":1012},
    {"title":"El paradigma Cliente/Servidor","resume":"El modelo Cliente/Servidor es un modelo de aplicación distribuida en el que las tareas se reparten entre los proveedores de recursos o servicios, llamados servidores, y los demandantes, llamados clientes. Las aplicaciones Clientes realizan peticiones a una o varias aplicaciones Servidores, que deben encontrarse en ejecución para atender dichas demandas.","content":"<h1 style=\"text-align: justify;\">El paradigma Cliente/Servidor</h1>\n<h2 style=\"text-align: justify;\">Definici&oacute;n de cliente y servidor</h2>\n<p style=\"text-align: justify;\"><img src=\"https://upload.wikimedia.org/wikipedia/commons/1/1c/Cliente-Servidor.png\" alt=\"\" width=\"461\" height=\"222\"></p>\n<h3 style=\"text-align: justify;\">Cliente</h3>\n<p style=\"text-align: justify;\">Es el que inicia un requerimiento de servicio. El requerimiento inicial puede convertirse en m&uacute;ltiples requerimientos de trabajo a trav&eacute;s de redes LAN o WAN. La ubicaci&oacute;n de los datos o de las aplicaciones es totalmente transparente para el cliente.</p>\n<h3 style=\"text-align: justify;\">Servidor</h3>\n<p style=\"text-align: justify;\">Es cualquier recurso de c&oacute;mputo dedicado a responder a los requerimientos del cliente. Los servidores pueden estar conectados a los clientes a trav&eacute;s de redes LANs o WANs, para proveer de m&uacute;ltiples servicios a los clientes y ciudadanos tales como impresi&oacute;n, acceso a bases de datos, fax, procesamiento de im&aacute;genes, etc.&nbsp;</p>\n<h2 style=\"text-align: justify;\">Definici&oacute;n del modelo cliente/servidor</h2>\n<p style=\"text-align: justify;\">El modelo Cliente/Servidor es un modelo de aplicaci&oacute;n distribuida en el que las tareas se reparten entre los proveedores de recursos o servicios, llamados servidores, y los demandantes, llamados clientes. Las aplicaciones Clientes realizan peticiones a una o varias aplicaciones Servidores, que deben encontrarse en ejecuci&oacute;n para atender dichas demandas.</p>\n<p style=\"text-align: justify;\">El modelo Cliente/Servidor permite diversificar el trabajo que realiza cada aplicaci&oacute;n, de forma que los Clientes no se sobrecarguen, cosa que ocurrir&iacute;a si ellos mismos desempe&ntilde;an las funciones que le son proporcionadas de forma directa y transparente. En esta arquitectura la capacidad de proceso est&aacute; repartida entre los clientes y los servidores, aunque son m&aacute;s importantes las ventajas de tipo organizativo debidas a la centralizaci&oacute;n de la gesti&oacute;n de la informaci&oacute;n y la separaci&oacute;n de responsabilidades, lo que facilita y clarifica el dise&ntilde;o del sistema. Tanto el Cliente como el Servidor son entidades abstractas que pueden residir en la misma m&aacute;quina o en m&aacute;quinas diferentes.</p>\n<p style=\"text-align: justify;\">Una disposici&oacute;n muy com&uacute;n son los sistemas multicapa en los que el servidor se descompone en diferentes programas que pueden ser ejecutados por diferentes computadoras aumentando as&iacute; el grado de distribuci&oacute;n del sistema.</p>\n<h2 style=\"text-align: justify;\">Modelo de servicios</h2>\n<p style=\"text-align: justify;\">Un modelo es una vista abstracta que establece las definiciones, reglas y relaciones entre las estructuras relacionadas con la aplicaci&oacute;n. Sirve de base para el intercambio de ideas durante el desarrollo l&oacute;gico de la aplicaci&oacute;n y determina c&oacute;mo ser&aacute; la aplicaci&oacute;n resultante.</p>\n<p style=\"text-align: justify;\">Tomemos el ejemplo de de una casa, autom&aacute;ticamente se asume que &eacute;sta tendr&aacute; un sal&oacute;n, habitaciones, ba&ntilde;os, cocina, etc., sin que se nos diga nada m&aacute;s. Aunque la casa no tuviera sal&oacute;n, el modelo nos servir&iacute;a como punto de partida para \"entender\" el concepto \"casa\" y empezar a discutir sobre ella. De igual manera, el modelo de una aplicaci&oacute;n nos indica lo que hace una aplicaci&oacute;n o m&aacute;s exactamente, lo que uno cree que debe hacer la aplicaci&oacute;n.</p>\n<p style=\"text-align: justify;\">El modelo de servicios establece tres grandes conjuntos de funcionalidades, en cada uno de los cuales se encuadran las distintas tareas en las que se ve involucrado cualquier tipo de proyecto de desarrollo. Dicho modelo establece los siguientes conjuntos que com&uacute;nmente denominamos l&oacute;gicas, las cuales son:</p>\n<ul style=\"text-align: justify;\">\n<li>L&oacute;gica de presentaci&oacute;n</li>\n<li>L&oacute;gica de negocio</li>\n<li>L&oacute;gica de datos</li>\n</ul>\n<h3 style=\"text-align: justify;\">L&oacute;gica de presentaci&oacute;n</h3>\n<p style=\"text-align: justify;\">Esta l&oacute;gica es la responsable del control de todos los aspectos relacionados con la interacci&oacute;n entre el usuario y la aplicaci&oacute;n. Para llevar a cabo esta tarea de control, es necesario conocer qu&eacute; tipos de usuarios utilizar&aacute;n la aplicaci&oacute;n, qu&eacute; actividades tienen que realizar y, teniendo en cuenta estos datos, cu&aacute;les son los mejores estilos de interfaz para que esos usuarios realicen sus tareas. En esta l&oacute;gica se engloban todas las tareas que deben ser realizadas por la parte Cliente del modelo general.</p>\n<p style=\"text-align: justify;\">Con el fin de independizar (en la medida de lo posible) la interfaz de usuario de las caracter&iacute;sticas propias de los procesos, debemos tener presente que la codificaci&oacute;n de las tareas asociadas a esta l&oacute;gica consiste, principalmente, en la llamada a procesos independientes situados en las otras l&oacute;gicas, cuya ejecuci&oacute;n es totalmente transparente. Si en la capa que implementa la l&oacute;gica de presentaci&oacute;n no incluimos l&oacute;gica del negocio ni accesos directos a datos, conseguiremos que esta capa sea inmune a los cambios introducidos en los procedimientos de la empresa, as&iacute; como a los cambios de los sistemas de gesti&oacute;n de datos utilizados.</p>\n<h3 style=\"text-align: justify;\">L&oacute;gica de Negocio</h3>\n<p style=\"text-align: justify;\">Es la l&oacute;gica de la aplicaci&oacute;n que controla la secuencia de acciones y fuerza el cumplimiento de las reglas del negocio propias de cada empresa; adem&aacute;s, asegura la integridad de las transacciones de las operaciones necesarias que haya que realizar para que se cumplan dichas reglas. La l&oacute;gica del negocio tambi&eacute;n transforma una serie de datos en informaci&oacute;n &uacute;til para el usuario mediante la aplicaci&oacute;n de las reglas apropiadas.</p>\n<p style=\"text-align: justify;\">El objetivo que debe cumplir esta l&oacute;gica es el de aislar las reglas del negocio, as&iacute; como las transformaciones de datos de los consumidores (usuarios y otros componentes de esta misma capa) y de los sistemas de gesti&oacute;n de datos. Este aislamiento tiene las siguientes ventajas:&nbsp;</p>\n<ul style=\"text-align: justify;\">\n<li>Flexibilidad a la hora de decidir c&oacute;mo y d&oacute;nde situar el c&oacute;digo de esta l&oacute;gica: en componentes dentro de una aplicaci&oacute;n servidora; en procedimientos almacenados, dentro del sistema gestor de datos; o incluso en el cliente.</li>\n<li>La habilidad de colocar distintas interfaces de usuario para un mismo conjunto est&aacute;ndar de reglas de negocio. Por ejemplo, el conjunto de reglas que define las operaciones realizables con los clientes puede implementarse como un solo componente que se ejecuta en un servidor. Los servicios que ofrece este componente pueden utilizarse desde una macro que se ejecute dentro de Microsoft Office, desde una aplicaci&oacute;n desarrollada con Visual Basic o desde p&aacute;ginas HTML vistas desde Internet Explorer.</li>\n<li>Facilita el mantenimiento de las reglas del negocio y de su l&oacute;gica, aislando los cambios de las interfaces de los usuarios y de los datos.</li>\n<li>La habilidad para sustituir el c&oacute;digo de estas reglas, de forma que, aunque el conjunto de reglas que se encuentra dentro de un conjunto de servicios del negocio var&iacute;a de un pa&iacute;s a otro, las interfaces de esos servicios pueden permanecer constantes.</li>\n</ul>\n<h3 style=\"text-align: justify;\">L&oacute;gica de Datos</h3>\n<p style=\"text-align: justify;\">En este conjunto entran los procesos encargados de la gesti&oacute;n de los datos propiamente dicha, es decir, los procesos encargados del mantenimiento de los datos, de garantizar las reglas de integridad referencial establecidas, as&iacute; como de la gesti&oacute;n de las transacciones. Estas tareas son realizadas, generalmente, por un Sistema de Gesti&oacute;n de Bases de Datos Relacionales, como SQL Server, Oracle, MySQL, Informix, etc.</p>\n<h2 style=\"text-align: justify;\">Modelo Cliente/Servidor 2 capas</h2>\n<p style=\"text-align: justify;\">Uno de los objetivos de las aplicaciones de 2 capas es separar la l&oacute;gica de acceso a los datos de lo que es la interfaz de usuario y trasladarla al servidor. Habitualmente, se implementan servicios como procedimientos almacenados en el sistema gestor de datos; con esto se pretende reducir la carga de los clientes y centralizar las operaciones comunes de acceso a los datos. El Sistema Gestor de Datos tambi&eacute;n suele incorporar la funcionalidad necesaria para trabajar en entornos multiusuarios.</p>\n<p style=\"text-align: justify;\">En este modelo intervienen &uacute;nicamente dos entidades: El Cliente y El Servidor.</p>\n<p style=\"text-align: justify;\">El papel de Cliente lo desempe&ntilde;a la aplicaci&oacute;n final del usuario, que implementar&aacute; todas las funciones correspondientes a la l&oacute;gica de presentaci&oacute;n, m&aacute;s algunas de las funciones relacionadas con la l&oacute;gica del negocio, como pueden ser determinadas validaciones de datos y condiciones de recuperaci&oacute;n.</p>\n<p style=\"text-align: justify;\">El papel de Servidor lo desempe&ntilde;a el propio SGBD, el cual se ocupar&aacute; de todas las funciones correspondientes a la l&oacute;gica de datos, m&aacute;s las restantes funciones correspondientes a la l&oacute;gica del negocio, mediante la codificaci&oacute;n de Procedimientos Almacenados.</p>\n<p style=\"text-align: justify;\">Este es el modelo C/S m&aacute;s sencillo y m&aacute;s utilizado habitualmente. En la mayor parte de los casos, el desarrollador de una aplicaci&oacute;n de este tipo, desarrolla &uacute;nicamente la aplicaci&oacute;n Cliente y utiliza al propio motor de BD como aplicaci&oacute;n servidora, de modo que no se codifica la aplicaci&oacute;n Servidora propiamente dicha.</p>\n<p style=\"text-align: justify;\"><img src=\"https://www.monografias.com/trabajos89/cliente-servidor-dos-capas/image001.gif\" alt=\"Cliente Servidor de dos capas\"></p>\n<h2 style=\"text-align: justify;\">Modelo Cliente/Servidor multicapa</h2>\n<p style=\"text-align: justify;\">La arquitectura cliente/servidor gen&eacute;rico tiene dos tipos de nodos en la red: clientes y servidores. Consecuentemente, estas arquitecturas gen&eacute;ricas se refieren a veces como arquitecturas de dos niveles o dos capas.</p>\n<p style=\"text-align: justify;\">Algunas redes disponen de tres tipos de nodos:</p>\n<ul style=\"text-align: justify;\">\n<li>Clientes que interact&uacute;an con los usuarios finales.</li>\n<li>Servidores de aplicaci&oacute;n que procesan los datos para los clientes.</li>\n<li>Servidores de la base de datos que almacenan los datos para los servidores de aplicaci&oacute;n.</li>\n</ul>\n<p style=\"text-align: justify;\">Esta configuraci&oacute;n se llama una arquitectura de tres capas.</p>\n<p style=\"text-align: justify;\">Este modelo aporta una flexibilidad adicional en la construcci&oacute;n de aplicaciones cuando &eacute;stas aumentan su complejidad. Influye tanto en el modelo de aplicaci&oacute;n (l&oacute;gicas de presentaci&oacute;n, del negocio y de datos) como en la distribuci&oacute;n de los servicios. El modelo conceptual de una aplicaci&oacute;n establece sus definiciones, reglas y relaciones as&iacute; como su estructura. Hay partes de la l&oacute;gica que residen en el cliente, normalmente las que se refieren a la interfaz de usuario, mientras que las del negocio y de datos suelen residir en los servidores, que proporcionan los mecanismos necesarios para el trabajo en entornos multiusuarios. En este tipo de modelo se aplica &iacute;ntegramente el modelo de servicios ya que, cada una de las capas se corresponde con cada una de las l&oacute;gicas descritas.</p>\n<p style=\"text-align: justify;\">En la actualidad las t&eacute;cnicas y lenguajes de programaci&oacute;n de servidores han avanzado de tal forma de permitir desarrollos modulares (por ejemplo mediante la arquitectura MVC, Model&shy;Control&shy;View), orientaci&oacute;n a objetos y existen innumerables frameworks y librer&iacute;as para simplificar la tarea de los desarrolladores de software. Una de las caracter&iacute;sticas principales de este modelo reside en la desconexi&oacute;n total entre la l&oacute;gica de presentaci&oacute;n y la l&oacute;gica de los datos. Las conexiones que se producen, se dan entre las l&oacute;gicas de presentaci&oacute;n y del negocio, y las l&oacute;gicas del negocio y la de datos.</p>\n<p style=\"text-align: justify;\">Este modelo hace que la aplicaci&oacute;n final sea completamente independiente del origen de los datos que procesa, tarea que pasa a ser competencia directa del componente especializado.</p>\n<p style=\"text-align: justify;\">A pesar de esto, no es necesario que las distintas l&oacute;gicas residan en m&aacute;quinas diferentes; en la mayor&iacute;a de los casos, es perfectamente compatible su implementaci&oacute;n en la misma m&aacute;quina, si bien este dise&ntilde;o no es el m&aacute;s habitual.</p>\n<p style=\"text-align: justify;\"><img src=\"https://upload.wikimedia.org/wikipedia/commons/e/ea/Tres_capas.PNG\" alt=\"Programaci&oacute;n por capas - Wikipedia, la enciclopedia libre\"></p>","date":"2022-05-27","autor":"","id":16154},
    {"title":"Socket","resume":"La programación en red siempre ha sido dificultosa, el programador debía de conocer la mayoría de los detalles de la red, incluyendo el hardware utilizado, los distintos niveles en que se divide la capa de red, las librerías necesarias para programar en cada capa, etc.","content":"<h1>Sockets en java</h1>\n<p>La programaci&oacute;n en red siempre ha sido dificultosa, el programador deb&iacute;a de conocer la mayor&iacute;a de los detalles de la red, incluyendo el hardware utilizado, los distintos niveles en que se divide la capa de red, las librer&iacute;as necesarias para programar en cada capa, etc.</p>\n<p>Pero, la idea simplemente consiste en obtener informaci&oacute;n desde otra máquina, aportada por otra aplicaci&oacute;n software. Por lo tanto, de cierto modo se puede reducir al mero hecho de leer y escribir archivos, con ciertas salvedades.</p>\n<p>El sistema de Entrada/Salida de Unix sigue el paradigma que normalmente se designa como Abrir-Leer-Escribir-Cerrar. Antes de que un proceso de usuario pueda realizar operaciones de entrada/salida, debe hacer una llamada a Abrir (open) para indicar, y obtener los permisos del fichero o dispositivo que se desea utilizar.</p>\n<p>Una vez que el fichero o dispositivo se encuentra abierto, el proceso de usuario realiza una o varias llamadas a Leer (read) y Escribir (write), para la lectura y escritura de los datos.</p>\n<p>El proceso de lectura toma los datos desde el objeto y los transfiere al proceso de usuario, mientras que el de escritura los transfiere desde el proceso de usuario al objeto. Una vez concluido el intercambio de informaci&oacute;n, el proceso de usuario llamar&aacute; a Cerrar (close) para informar al sistema operativo que ha finalizado la utilizaci&oacute;n del fichero o dispositivo</p>\n<p>En Unix, un proceso tiene un conjunto de descriptores de entrada/salida desde donde leer y por donde escribir. Estos descriptores pueden estar referidos a ficheros, dispositivos, o canales de comunicaciones sockets.</p>\n<p>El ciclo de vida de un descriptor, aplicado a un canal de comunicaci&oacute;n (por ejemplo, un socket), est&aacute; determinado por tres fases:</p>\n<ul>\n<li>Creaci&oacute;n, apertura del socket</li>\n<li>Lectura y Escritura, recepci&oacute;n y env&iacute;o de datos por el socket</li>\n<li>Destrucci&oacute;n, cierre del socket</li>\n</ul>\n<p>La interface IPC en Unix-BSD est&aacute; implementada sobre los protocolos de red TCP y UDP. Los destinatarios de los mensajes se especifican como direcciones de socket; cada direcci&oacute;n de socket es un identificador de comunicaci&oacute;n que consiste en una direcci&oacute;n Internet y un n&uacute;mero de puerto.</p>\n<p>Una de las caracter&iacute;sticas m&aacute;s importantes de Java es su capacidad y, a la vez, facilidad para realizar aplicaciones que funcionen en red. La mayor&iacute;a de los detalles de implementaci&oacute;n a bajo nivel est&aacute;n ocultos y son tratados de forma transparente por la JVM (Java Virtual Machine). Los programas son independientes de la arquitectura y se ejecutan indistintamente en una gran variedad de equipos con diferentes tipos de microprocesadores y sistemas operativos.</p>\n<h1>Clases para las comunicaciones de red en java: java.net</h1>\n<p>En las aplicaciones en red es muy com&uacute;n el paradigma cliente-servidor. El servidor es el que espera las conexiones del cliente (en un lugar claramente definido) y el cliente es el que lanza las peticiones a la maquina donde se est&aacute; ejecutando el servidor, y al lugar donde est&aacute; esperando el servidor (el puerto(s) espec&iacute;fico que atiende). Una vez establecida la conexi&oacute;n, &eacute;sta es tratada como un stream (flujo) t&iacute;pico de entrada/salida.</p>\n<p>Cuando se escriben programas Java que se comunican a trav&eacute;s de la red, se est&aacute; programando en la capa de aplicaci&oacute;n. T&iacute;picamente, no se necesita trabajar con las capas TCP y UDP, en su lugar se puede utilizar las clases del paquete java.net. Estas clases proporcionan comunicaci&oacute;n de red independiente del sistema.</p>\n<p>A trav&eacute;s de las clases del paquete java.net, los programas Java pueden utilizar TCP o UDP para comunicarse a trav&eacute;s de Internet. Las clases URL, URLConnection, Socket, y SocketServer utilizan TCP para comunicarse a trav&eacute;s de la Red. Las clases DatagramPacket y DatagramServer utilizan UDP.</p>\n<p>TCP proporciona un canal de comunicaci&oacute;n fiable punto a punto, lo que utilizan para comunicarse las aplicaciones cliente-servidor en Internet. Las clases Socket y ServerSocket del paquete java.net proporcionan un canal de comunicaci&oacute;n independiente del sistema utilizando TCP, cada una de las cuales implementa el lado del cliente y el servidor respectivamente.</p>\n<p>As&iacute; el paquete java.net proporciona, entre otras, las siguientes clases, que son las que se ver&aacute;n con detalle:</p>\n<ul>\n<li>Socket: Implementa un extremo de la conexi&oacute;n TCP.</li>\n<li>ServerSocket: Se encarga de implementar el extremo Servidor de la conexi&oacute;n en la que se esperar&aacute;n las conexiones de los clientes.</li>\n<li>DatagramSocket: Implementa tanto el servidor como el cliente cuando se utiliza UDP.</li>\n<li>DatagramPacket: Implementa un datagram packet, que se utiliza para la creaci&oacute;n de servicios de reparto de paquetes sin conexi&oacute;n.</li>\n<li>InetAddress: Se encarga de implementar la direcci&oacute;n IP.</li>\n</ul>\n<h1>DatagramSocket (Servicio sin Conexi&oacute;n)</h1>\n<p>Es el m&aacute;s simple, lo &uacute;nico que se hace es enviar los datos, mediante la creaci&oacute;n de un socket y utilizando los m&eacute;todos de env&iacute;o y recepci&oacute;n apropiados.</p>\n<p>Se trata de un servicio de transporte sin conexi&oacute;n. Son m&aacute;s eficientes que TCP, pero no est&aacute; garantizada la fiabilidad: los datos se env&iacute;an y reciben en paquetes, cuya entrega no est&aacute; garantizada; los paquetes pueden ser duplicados, perdidos o llegar en un orden diferente al que se envi&oacute;.</p>\n<p>El protocolo de comunicaciones con datagramas UDP, es un protocolo sin conexi&oacute;n, es decir, cada vez que se env&iacute;en datagramas es necesario enviar el descriptor del socket local y la direcci&oacute;n del socket que debe recibir el datagrama. Como se puede ver, hay que enviar datos adicionales cada vez que se realice una comunicaci&oacute;n.</p>\n<p>public class java.net.DatagramSocket extends java.lang.Object</p>\n<h2><span style=\"text-decoration: underline; color: rgb(0, 0, 0);\">Constructores</span></h2>\n<p><strong>public DatagramSocket () throws SocketException</strong></p>\n<p>Se encarga de construir un socket para datagramas y de conectarlo al primer puerto disponible.</p>\n<p><strong>public DatagramSocket (int port) throws SocketException</strong></p>\n<p>&Iacute;dem, pero con la salvedad de que permite especificar el n&uacute;mero de puerto asociado.</p>\n<p><strong>public DatagramSocket (int port, InetAddress ip) throws SocketException</strong></p>\n<p>Permite especificar, adem&aacute;s del puerto, la direcci&oacute;n local a la que se va a asociar el socket.</p>\n<h2><span style=\"text-decoration: underline;\">M&eacute;todos </span><!--[endif]--></h2>\n<p><strong>public void close()</strong></p>\n<p>Cierra el socket.</p>\n<p><strong>protected void finalize()</strong></p>\n<p>Asegura el cierre del socket si no existen m&aacute;s referencias al mismo.</p>\n<p><strong>public int getLocalPort()</strong></p>\n<p>Retorna el n&uacute;mero de puerto en el host local al que est&aacute; conectado el socket.</p>\n<p><strong>public void receive (DatagramPacket p) throws IOException</strong></p>\n<p>Recibe un DatagramPacket del socket, y llena el b&uacute;fer con los datos que recibe.</p>\n<p><strong>public void send (DatagramPacket p) throws IOException</strong></p>\n<p>Env&iacute;a un DatagramPacket a trav&eacute;s del socket.</p>\n<h1>DatagramPacket</h1>\n<p>Un DatagramSocket env&iacute;a y recibe los paquetes y un DatagramPacket contiene la informaci&oacute;n relevante. Cuando se desea recibir un datagrama, &eacute;ste deber&aacute; almacenarse bien en un b&uacute;fer o un array de bytes. Y cuando preparamos un datagrama para ser enviado, el DatagramPacket no s&oacute;lo debe tener la informaci&oacute;n, sino que adem&aacute;s debe tener la direcci&oacute;n IP y el puerto de destino, que puede coincidir con un puerto TCP.</p>\n<p><strong>public final class java.net.DatagramPacket extends java.lang.Object</strong></p>\n<h2><span style=\"text-decoration: underline;\">Constructores</span></h2>\n<p><strong>public DatagramPacket(byte ibuf[], int ilength)</strong></p>\n<p>Implementa un DatagramPacket para la recepci&oacute;n de paquetes de longitud ilength, siendo el valor de este par&aacute;metro menor o igual que ibuf.length</p>\n<p><strong>public DatagramPacket(byte ibuf[], int ilength, InetAddress iaddr, int iport)</strong></p>\n<p>Implementa un DatagramPacket para el env&iacute;o de paquetes de longitud ilength al n&uacute;mero de puerto especificado en el par&aacute;metro iport, del host especificado en la direcci&oacute;n de destino que se le pasa por medio del par&aacute;metro iaddr.<!--[endif]--></p>\n<h2><span style=\"text-decoration: underline;\">M&eacute;todos </span><!--[endif]--></h2>\n<p><strong>public InetAddress getAddress ()</strong></p>\n<p>Retorna la direcci&oacute;n IP del host al cual se le env&iacute;a el datagrama o del que el datagrama se recibi&oacute;.</p>\n<p><strong>public byte[] getData()</strong></p>\n<p>Retorna los datos a recibir o a enviar.</p>\n<p><strong>public int getLength()</strong></p>\n<p>Retorna la longitud de los datos a enviar o a recibir.</p>\n<p><strong>public int getPort()</strong></p>\n<p>Retorna el n&uacute;mero de puerto de la m&aacute;quina remota a la que se le va a enviar el datagrama o del que se recibi&oacute;</p>\n<h1>StreamSocket (Servicio Orientado a Conexi&oacute;n - Servidor)</h1>\n<p>Es un servicio orientado a conexi&oacute;n donde los datos se transfieren sin encuadrarlos en registros o bloques. Si se rompe la conexi&oacute;n entre los procesos, &eacute;stos ser&aacute;n informados. El protocolo de comunicaciones con streams es un protocolo orientado a conexi&oacute;n, ya que para establecer una comunicaci&oacute;n utilizando el protocolo TCP, hay que establecer en primer lugar una conexi&oacute;n entre un par de sockets. Mientras uno de los sockets atiende peticiones de conexi&oacute;n (servidor), el otro solicita una conexi&oacute;n (cliente). Una vez que los dos sockets est&eacute;n conectados, se pueden utilizar para transmitir datos en ambas direcciones.</p>\n<p>Permite a las aplicaciones Cliente y Servidor, disponer de un stream que facilita la comunicaci&oacute;n entre ambos, obteni&eacute;ndose una mayor fiabilidad.</p>\n<p>El funcionamiento es diferente al anterior ya que cada extremo se comportar&aacute; de forma diferente, el servidor adopta un papel (inicial) pasivo y espera conexiones de los clientes. Mientras que el cliente adoptar&aacute; un papel (inicial) activo, solicitando conexiones al servidor.</p>\n<p>En la parte del SERVIDOR se tiene:</p>\n<p><strong>public final class java.net.ServerSocket extends java.lang.Object</strong></p>\n<h2><span style=\"text-decoration: underline;\">Constructores</span><!--[endif]--></h2>\n<p><strong>public ServerSocket (int port) throws IOException</strong></p>\n<p>Se crea un socket local al que se enlaza el puerto especificado en el par&aacute;metro port, si se especifica un 0 en dicho par&aacute;metro crear&aacute; el socket en cualquier puerto disponible. Puede aceptar hasta 50 peticiones en cola pendientes de conexi&oacute;n por parte de los clientes.</p>\n<p><strong>public ServerSocket (int port , int count) throws IOException</strong></p>\n<p>Aqu&iacute;, el par&aacute;metro count sirve para que puede especificarse, el n&uacute;mero m&aacute;ximo de peticiones de conexi&oacute;n que se pueden mantener en cola. Hay que recordar, que es fundamental que el puerto escogido sea conocido por el cliente, en caso contrario, no se podr&iacute;a establecer la conexi&oacute;n.</p>\n<h2><span style=\"text-decoration: underline;\">M&eacute;todos </span><!--[endif]--></h2>\n<p><strong>public Socket accept () throws IOException</strong></p>\n<p>Sobre un ServerSocket se puede realizar una espera de conexi&oacute;n por parte del cliente mediante el m&eacute;todo accept(). Hay que decir, que este m&eacute;todo es de bloqueo, el proceso espera a que se realice una conexi&oacute;n por parte del cliente para seguir su ejecuci&oacute;n. Una vez que se ha establecido una conexi&oacute;n por el cliente, e</p>\n<p><strong>public void close () throws IOException</strong></p>\n<p>Se encarga de cerrar el socket</p>\n<p><strong>public InetAddress getInetAddress ()</strong></p>\n<p>Retorna la direcci&oacute;n IP remota a la cual est&aacute; conectado el socket. Si no lo est&aacute; retornar&aacute; null .</p>\n<p><strong>public int getLocalPort ()</strong></p>\n<p>Retorna el puerto en el que est&aacute; escuchando el socket.</p>\n<p><strong>public static void setSocketImplFactory (SocketImplFactory fac) throws IOException</strong></p>\n<p>Este m&eacute;todo establece la compa&ntilde;&iacute;a de implementaci&oacute;n del socket para la aplicaci&oacute;n. Debido a que cuando una aplicaci&oacute;n crea un nuevo socket, se realiza una llamada al m&eacute;todo createSocketImpl() de la compa&ntilde;&iacute;a que implementa al socket. Es por tanto en el par&aacute;metro fac, donde se especificar&aacute; la citada compa&ntilde;&iacute;a.</p>\n<p><strong>public String toString( )</strong></p>\n<p>Retorna un string representando el socket</p>\n<h1>StreamSocket (Servicio Orientado a Conexi&oacute;n - Cliente)</h1>\n<p>En la parte del Cliente se tiene:</p>\n<p><strong>public final class java.net.Socket extends java.lang.Object</strong></p>\n<h2><span style=\"text-decoration: underline;\">Constructores</span><!--[endif]--></h2>\n<p><strong>public Socket (InetAddress address, int port) throws IOException</strong></p>\n<p>Crea un StreamSocket y lo conecta al puerto remoto y direcci&oacute;n IP remota especificados.</p>\n<p><strong>public Socket (InetAddress address, int port , boolean stream) throws IOException</strong></p>\n<p>&Iacute;dem a la anterior incluyendo el par&aacute;metro booleano stream que si es true crear&aacute; un StreamSocket y si es false un DatagramSocket (En desuso).</p>\n<p><strong>public Socket (String host, int port) throws UnKnownHostException, IOException</strong></p>\n<p>Crea un StreamSocket y lo conecta al n&uacute;mero de puerto y al nombre de host especificados.</p>\n<p><strong>public Socket (String host , int port , boolean stream) throws IOException</strong></p>\n<p>&Iacute;dem al anterior incluyendo el par&aacute;metro booleano stream que si es true crear&aacute; un StreamSocket y si es false un DatagramSocket (En desuso).</p>\n<h2><span style=\"text-decoration: underline;\">M&eacute;todos </span><!--[endif]--></h2>\n<p><strong>public void close() throws IOException</strong></p>\n<p>Se encarga de cerrar el socket.</p>\n<p><strong>public InetAddress getInetAddress ()</strong></p>\n<p>Retorna la direcci&oacute;n IP remota a la que se conecta el socket.</p>\n<p><strong>public InputStream getInputStream () throws IOException</strong></p>\n<p>Retorna un input stream para la lectura de bytes desde el socket.</p>\n<p><strong>public int getLocalPort()</strong></p>\n<p>Retorna el puerto local al que est&aacute; conectado el socket.</p>\n<p><strong>public OutputStream getOutputStream () throws IOException</strong></p>\n<p>Retorna un output stream para la escritura de bytes hacia el socket.</p>\n<p><strong>public int getPort ()</strong></p>\n<p>Retorna el puerto remoto al que est&aacute; conectado el socket.</p>\n<p><strong>public static void setSocketImplFactory (SocketImplFactory fac) throws IOException</strong></p>\n<p>Este m&eacute;todo establece la compa&ntilde;&iacute;a de implementaci&oacute;n del socket para la aplicaci&oacute;n. Debido a que cuando una aplicaci&oacute;n crea un nuevo socket, se realiza una llamada al m&eacute;todo createSocketImpl( ) de la compa&ntilde;&iacute;a que implementa al socket. Es por tanto en el par&aacute;metro fac, donde especificaremos la citada compa&ntilde;&iacute;a.</p>\n<h1>Clase InetAddress</h1>\n<p>Esta clase implementa la direcci&oacute;n IP.</p>\n<p><strong>public final class java.net.InetAddress extends java.lang.Object</strong></p>\n<h2><span style=\"text-decoration: underline;\">Constructores</span><!--[endif]--></h2>\n<p>Para crear una nueva instancia de esta clase se debe de llamar a los m&eacute;todos:</p>\n<ul>\n<li><strong>getLocalHost()</strong></li>\n<li><strong>getByname()</strong> o <strong>getAllByName()</strong></li>\n</ul>\n<h2><span style=\"text-decoration: underline;\">M&eacute;todos </span><!--[endif]--></h2>\n<p><strong>public boolean equals (Object obj)</strong></p>\n<p>Devuelve un booleano a true si el par&aacute;metro que se la pasa no es null e implementa la misma direcci&oacute;n IP que el objeto. Dos instancias de InetAddress implementan la misma direcci&oacute;n IP si la longitud del vector de bytes que nos devuelve el m&eacute;todo getAddress() es la misma para ambas y cada uno de los componentes del vector de componentes es el mismo que el vector de bytes.</p>\n<p><strong>public byte[] getAddress () &nbsp;</strong></p>\n<p>Retorna la direcci&oacute;n raw IP del objeto InetAddress.</p>\n<p>Hay que tener en cuenta que el byte de mayor orden de la direcci&oacute;n estar&aacute; en <strong>getAddress()[0]</strong>.</p>\n<p><strong>public static InetAddress[] getAllByName(String host) throws UnknownHostException</strong></p>\n<p>Retorna un vector con todas las direcciones IP del host especificado en el par&aacute;metro.</p>\n<p><strong>public static InetAddress getByName (String host) throws UnknownHostException</strong></p>\n<p>Retorna la direcci&oacute;n IP del nombre del host que se le pasa como par&aacute;metro, aunque tambi&eacute;n se le puede pasar un string representando su direcci&oacute;n IP.</p>\n<p><strong>public String getHostName()</strong></p>\n<p>Retorna el nombre del host para esta direcci&oacute;n IP.</p>\n<p><strong>public static InetAddress getLocalHost() throws UnknownHostException</strong></p>\n<p>Retorna la direcci&oacute;n IP para el host local.</p>\n<p><strong>public int hashCode()</strong></p>\n<p>Retorna un c&oacute;digo hash para esta direcci&oacute;n IP.</p>\n<p><strong>public String toString()</strong></p>\n<p>Retorna un String representando la direcci&oacute;n IP</p>\n<h1>Envio y recepci&oacute;n a trav&eacute;s de sockets</h1>\n<p>El servidor crear&aacute; un socket, utilizando ServerSocket, le asignar&aacute; un puerto y una direcci&oacute;n, una vez haga el accept para esperar llamadas, se quedar&aacute; bloqueado a la espera de las mismas. Una vez llegue una llamada el accept crear&aacute; un Socket para procesarla.</p>\n<p>A su vez, cuando un cliente desee establecer una conexi&oacute;n, crear&aacute; un socket y establecer&aacute; una conexi&oacute;n al puerto establecido. S&oacute;lo es en este momento, cuando se da una conexi&oacute;n real y se mantendr&aacute; hasta su liberaci&oacute;n mediante <strong>close()</strong>.</p>\n<p>Para poder leer y escribir datos, los sockets disponen de unos stream asociados, uno de entrada (InputStream) y otro de salida (OutputStream) respectivamente</p>\n<p>Para obtener estos streams a partir del socket utilizaremos:</p>\n<p><strong>ObjetoDeTipoSocket.getInputStream()</strong></p>\n<p>Devuelve un objeto de tipo InputStream.</p>\n<p><strong>ObjetoDeTipoSocket.getOutputStream()</strong></p>\n<p>Devuelve un objeto de tipo OutputStream.</p>\n<p>Para el env&iacute;o de datos, puede utilizarse OutputStream directamente en el caso de que se quiera enviar un flujo de bytes sin b&uacute;fer o tambi&eacute;n puede crearse un objeto de tipo stream basado en el OutputStream que proporciona el socket.</p>\n<p>En Java, crear una conexi&oacute;n socket TCP/IP se realiza directamente con el paquete java.net.</p>\n<p>El servidor establece un puerto y espera a que el cliente establezca la conexi&oacute;n.</p>\n<p>Cuando el cliente solicite una conexi&oacute;n, el servidor abrir&aacute; la conexi&oacute;n socket con el m&eacute;todo accept(). El cliente establece una conexi&oacute;n con la m&aacute;quina host a trav&eacute;s del puerto que se designe en port#. El cliente y el servidor se comunican con manejadores <strong>InputStream</strong> y <strong>OutputStream</strong>.</p>\n<h1>Creaci&oacute;n de Streams</h1>\n<h2>Creaci&oacute;n de Streams de Entrada</h2>\n<p>En la parte cliente de la aplicaci&oacute;n, se puede utilizar la clase DataInputStream para crear un stream de entrada que est&eacute; listo a recibir todas las respuestas que el servidor le env&iacute;e.</p>\n<h3>Cliente</h3>\n<p><strong>DataInputStream inSocket;</strong></p>\n<p><strong>try {</strong></p>\n<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inSocket= new DataInputStream(miSocket.getInputStream());</strong></p>\n<p><strong>&nbsp;} catch( IOException e ) {</strong></p>\n<p><strong>&nbsp;&nbsp;&nbsp; System.out.println( e );</strong></p>\n<p><strong>}</strong></p>\n<p>La clase <strong>DataInputStream </strong>permite la lectura de l&iacute;neas de texto y tipos de datos primitivos de Java de un modo altamente portable; dispone de m&eacute;todos para leer todos esos tipos como: <strong>read()</strong>, <strong>readChar()</strong>, <strong>readInt()</strong>, <strong>readDouble()</strong> y <strong>readUTF()</strong>.</p>\n<p>Deber&aacute; utilizarse la funci&oacute;n que se crea necesaria dependiendo del tipo de dato que se espera recibir del servidor. En el lado del servidor, tambi&eacute;n se usar&aacute; DataInputStream, pero en este caso para recibir las entradas que se produzcan de los clientes que se hayan conectado:</p>\n<h3>Servidor</h3>\n<p><strong>DataInputStream inSocket;</strong></p>\n<p><strong>try {</strong></p>\n<p><strong>&nbsp;&nbsp; inSocket = new DataInputStream(socketServicio.getInputStream()); &nbsp;</strong></p>\n<p><strong>} catch( IOException e ) {</strong></p>\n<p><strong>&nbsp; System.out.println( e );</strong></p>\n<p><strong>}</strong></p>\n<h2><strong>Creaci&oacute;n de Streams de Salidas</strong></h2>\n<p>La clase <strong>PrintStream </strong>tiene m&eacute;todos para la representaci&oacute;n textual de todos los datos primitivos de Java. Sus m&eacute;todos <strong>write </strong>y <strong>println()</strong> tienen una especial importancia en este aspecto. No obstante, para el env&iacute;o de informaci&oacute;n al servidor tambi&eacute;n podemos utilizar <strong>DataOutputStream</strong>:</p>\n<h3>Clase DataOutputStream Cliente</h3>\n<p><strong>DataOutputStream outSocket;</strong></p>\n<p><strong>try {</strong></p>\n<p><strong>&nbsp;&nbsp;&nbsp; outSocket= new DataOutputStream(miSocket.getOutputStream());</strong></p>\n<p><strong>} catch(IOException e) {</strong></p>\n<p><strong>&nbsp;&nbsp;&nbsp; System.out.println( e );</strong></p>\n<p><strong>}</strong></p>\n<p>La clase DataOutputStream permite escribir cualquiera de los tipos primitivos de Java, muchos de sus m&eacute;todos escriben un tipo de dato primitivo en el stream de salida. De todos esos m&eacute;todos, el m&aacute;s &uacute;til quiz&aacute;s sea <strong>writeBytes()</strong>. En el lado del servidor, puede utilizarse la clase PrintStream para enviar informaci&oacute;n al cliente:</p>\n<h3>Clase DataOutputStream Servidor</h3>\n<p><strong>DataInputStream inSocket;</strong></p>\n<p><strong>try {</strong></p>\n<p><strong>&nbsp;&nbsp;&nbsp; outSocket= new PrintStream(socketServicio.getOutputStream());</strong></p>\n<p><strong>&nbsp;} catch( IOException e ) {&nbsp;</strong></p>\n<p><strong>&nbsp;&nbsp;&nbsp; System.out.println( e );</strong></p>\n<p><strong>}</strong></p>\n<p>Pero tambi&eacute;n puede utilizarse la clase <strong>DataOutputStream </strong>como en el caso de env&iacute;o de informaci&oacute;n desde el cliente.</p>\n<h1>Cierre de Socket</h1>\n<p>Siempre deben cerrarse los canales de entrada y salida que se hayan abierto durante la ejecuci&oacute;n de la aplicaci&oacute;n.</p>\n<h2>Cliente</h2>\n<p><strong>try {</strong></p>\n<p><strong>&nbsp; outSocket.close(); inSocket.close(); miSocket.close();</strong></p>\n<p><strong>} catch(IOException e) {</strong></p>\n<p><strong>&nbsp; System.out.println(e);</strong></p>\n<p><strong>}</strong></p>\n<h2>Servidor</h2>\n<p><strong>try {</strong></p>\n<p><strong>&nbsp; outSocket.close(); inSocket.close(); socketServicio.close(); socketSrv.close();</strong></p>\n<p><strong>} catch(IOException e) {</strong></p>\n<p><strong>&nbsp; System.out.println(e);</strong></p>\n<p><strong>}</strong></p>\n<h1>Diferencias entre sockets stream y datagrama</h1>\n<h2>UDP</h2>\n<p>Cada vez que se env&iacute;a un datagrama, hay que enviar tambi&eacute;n el descriptor del socket local y la direcci&oacute;n del socket que va a recibir el datagrama, luego &eacute;stos son m&aacute;s grandes que los TCP.</p>\n<p>Hay un l&iacute;mite de tama&ntilde;o de los datagramas, establecido en 64 kilobytes, que se pueden enviar a una localizaci&oacute;n determinada.</p>\n<p>UDP es un protocolo desordenado, no garantiza que los datagramas que se hayan enviado sean recibidos en el mismo orden por el socket de recepci&oacute;n.</p>\n<h2>TCP</h2>\n<p>Est&aacute; orientado a conexi&oacute;n, tiene que establecerse esta conexi&oacute;n entre los dos sockets antes de nada, lo que implica un cierto tiempo empleado en el establecimiento de la conexi&oacute;n, que no existe en UDP.</p>\n<p>TCP no tiene l&iacute;mite; una vez que se ha establecido la conexi&oacute;n, el par de sockets funciona como los streams.</p>\n<p>TCP es un protocolo ordenado, garantiza que todos los paquetes que se env&iacute;en ser&aacute;n recibidos en el socket destino en el mismo orden en que se han enviado.</p>\n<p>En resumen, TCP parece m&aacute;s indicado para la implementaci&oacute;n de servicios de red como un control remoto (rlogin, telnet) y transmisi&oacute;n de ficheros (ftp), que necesitan transmitir datos de longitud indefinida. UDP es menos complejo y tiene una menor sobrecarga sobre la conexi&oacute;n, esto hace que sea el indicado en la implementaci&oacute;n de aplicaciones cliente/servidor en sistemas distribuidos montados sobre redes de &aacute;rea local.</p>\n<h1>Implementaci&oacute;n sockets</h1>\n<ul>\n<li>Los m&eacute;todos est&aacute;ticos: <strong>getByName()</strong> y <strong>getAllByName()</strong>, reciben un par&aacute;metro que es el nombre o la direcci&oacute;n IP del servidor y devuelve la instancia correspondiente de lnetAddress. El tercer m&eacute;todo,<strong> getLocalHost ()</strong>, devuelve una instancia de lnetAddress que contiene la direcci&oacute;n del host local.&nbsp;</li>\n<li>Los m&eacute;todos din&aacute;micos <strong>getHostname()</strong> y <strong>getHostAddress()</strong>, sus funciones son obvias, dadas por sus nombres.</li>\n</ul>\n<h2>Ejemplo</h2>\n<h3>App de escritorio - JFrame</h3>\n<p>Se encuentra un boton Get Local Address para obtener el host local.</p>\n<p><img src=\"https://i.imgur.com/ZFqixsy.png\"></p>\n<p><strong>JOptionPane.showMessageDialog(this, getLocalAddress());</strong></p>\n<p><img src=\"https://i.imgur.com/vpsRmOJ.png\"></p>\n<h3>GetLocalAddress</h3>\n<h3><img src=\"https://i.imgur.com/pdCeKcj.png\"></h3>\n<h3>Programaci&oacute;n del bot&oacute;n Obtener Host Remoto</h3>\n<p>La clase InetAddress demuestra c&oacute;mo se podr&aacute; identificar un servidor para hacer las conexiones con Sockets. Entonces teniendo esta idea se podr&aacute; establecer una conexi&oacute;n a un mismo servidor desde diferentes m&aacute;quinas (clientes).</p>\n<p><img src=\"https://i.imgur.com/se8j6Le.png\"></p>\n<h2>Formulario principal&nbsp;</h2>\n<p>Socket API es una instalaci&oacute;n de programaci&oacute;n de bajo nivel para implementar la comunicaci&oacute;n entre procesos, (Interprocess communication, IPC). Las instalaciones de capa superior est&aacute;n construidas sobre las operaciones proporcionadas por la API de Socket. Esta API realiza los procedimientos necesarios para llevar a cabo la comunicaci&oacute;n entre el servidor y distintos clientes.</p>\n<p><img src=\"https://i.imgur.com/MvuyPOu.png\"></p>\n<p><img src=\"https://i.imgur.com/BDxzGfU.png\"></p>\n<p><img src=\"https://i.imgur.com/rhYdrSu.png\"></p>\n<h2>Formulario Chat</h2>\n<p><img src=\"https://i.imgur.com/FCgIiAt.png\"></p>\n<p><img src=\"https://i.imgur.com/ZTe2wgN.png\"></p>\n<p><img src=\"https://i.imgur.com/878VdlZ.png\"></p>\n<p>El m&eacute;todo update se activa cada vez que se ha recibido una petici&oacute;n notificando al cliente que en este caso es concatenar el mensaje enviado a la visualizaci&oacute;n del remitente</p>\n<h3>Clase Servidor</h3>\n<p><img src=\"https://i.imgur.com/PUr0s7p.png\" width=\"712\" height=\"384\"></p>\n<p>Este segmento de c&oacute;digo es la acci&oacute;n se realiza en el m&eacute;todo run de la clase Thread. Lo que hace este m&eacute;todo es que cuando haya recibido un nuevo mensaje se enviar&aacute; al cliente a quien haya sido enviado dicho mensaje.</p>\n<h3>Clase Cliente - Constructores</h3>\n<p><img src=\"https://i.imgur.com/lGabjIe.png\"></p>\n<p>Se asignan valores para las variables puerto y mensaje. El mensaje se recibe del formulario del chat para ser enviado a los dem&aacute;s receptores. Adem&aacute;s de este constructor se cuenta con un constructor de tres par&aacute;metros.</p>\n<p><img src=\"https://i.imgur.com/K7twQqy.png\"></p>\n<p>El segundo constructor tiene un tercer par&aacute;metro debido a que se pueden conectar clientes desde otros host al servidor de la aplicaci&oacute;n. Este proceso se realiza con un objeto de la clase InetAddress utilizada en el primer ejemplo. En el primer constructor anterior el objeto InetAddress obtiene el host local de la computadora.</p>\n<h3>Clase Cliente - M&eacute;todo run</h3>\n<p><img src=\"https://i.imgur.com/6n90gnM.png\" width=\"737\" height=\"331\"></p>\n<p>Esta operaci&oacute;n se lleva a cabo con el m&eacute;todo run de la clase Cliente. El m&eacute;todo realiza el env&iacute;o al servidor para que se encargue de enviar a los clientes conectados en la sala del chat.</p>\n<p>&nbsp;</p>","date":"2022-06-10","autor":"","id":21164}

  ]

  constructor() {

  }

  getBlogs() {
    return this.blogs_json;
  }

  getBlog(id: number) {
    //return this.blogs.find(blog => blog.id === id);
  }

  //make a json file
  generateBlog(title: string, content: string, date: any, autor: string) {
    let json = {
      title: title,
      content: content,
      date: date,
      autor: autor,
      id: this.getRandomInt(100000)
    }

    this.blogs.push(json);
  }

  //get the src of the first image in the content of the blog
  getFirstImage(content: string) {
    let regex = /<img[^>]+src="([^"]+)"/g;
    let match = regex.exec(content);
    return match![1];
  }

  //getBlogByTitle
  getBlogByTitle(title: string) {
    return this.blogs_json.map(blog => {
      if (blog.title.toLowerCase().includes(title.toLowerCase())) {
        return blog;
      }
    })
  }

  //getBlogBylastDate
  getBlogByLastDate() {
    return this.blogs_json.find(blog => blog.date === this.blogs_json[this.blogs_json.length - 1].date);
  }

  getBlogById(id: number) {
    return this.blogs_json.find(blog => blog.id === id);
  }

  getRandomInt(arg0: number) {
    return Math.floor(Math.random() * Math.floor(arg0));
  }

}
