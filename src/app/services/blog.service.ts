import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root'
})
export class BlogService {

  blogs: any[] = []

  blogs_json: any[] = [
    {"title":"Introducción a la computación distribuidas","content":"<h1>La computaci&oacute;n distribuida</h1>\n<p>La computaci&oacute;n distribuida es un modelo para resolver problemas de <a href=\"https://es.wikipedia.org/wiki/Computaci%C3%B3n\">computaci&oacute;n</a> masiva utilizando un gran n&uacute;mero de <a href=\"https://es.wikipedia.org/wiki/Computadora_electr%C3%B3nica\">ordenadores</a> organizados en <a href=\"https://es.wikipedia.org/wiki/Cluster_(inform%C3%A1tica)\">cl&uacute;steres</a> incrustados en una infraestructura de telecomunicaciones distribuida.</p>\n<p>La computaci&oacute;n distribuida es un modelo inform&aacute;tico que permite hacer grandes c&aacute;lculos utilizando miles de ordenadores de voluntarios. Este sistema se basa en repartir la informaci&oacute;n a trav&eacute;s de Internet mediante un software, previamente descargado por el usuario, a diferentes ordenadores, que van resolviendo los c&aacute;lculos y una vez tienen el resultado lo env&iacute;an al servidor. Este proyecto, casi siempre solidarios, reparten la informaci&oacute;n a procesar entre los miles de ordenadores voluntarios para poder alcanzar cuotas de procesamiento a menudo mayores que las de <a href=\"https://es.wikipedia.org/wiki/Superordenador\">superordenadores</a>.</p>\n<h2>Computaci&oacute;n Paralela</h2>\n<p>La&nbsp;<a href=\"https://es.wikipedia.org/wiki/Computaci%C3%B3n_paralela\" target=\"_blank\" rel=\"noopener\"><strong>computaci&oacute;n paralela</strong></a> es una forma de c&oacute;mputo en la que muchas&nbsp;instrucciones&nbsp;se ejecutan simult&aacute;neamente,<sup id=\"cite_ref-1\"></sup>​ operando sobre el principio de que problemas grandes, a menudo se pueden dividir en unos m&aacute;s peque&ntilde;os, que luego son resueltos simult&aacute;neamente (en paralelo). Hay varias formas diferentes de computaci&oacute;n paralela: paralelismo a nivel de bit, paralelismo a nivel de instrucci&oacute;n, paralelismo de datos y paralelismo de tareas. El paralelismo se ha empleado durante muchos a&ntilde;os, sobre todo en la computaci&oacute;n de altas prestaciones, pero el inter&eacute;s en ella ha crecido &uacute;ltimamente debido a las limitaciones f&iacute;sicas que impiden el aumento de la frecuencia. <sup id=\"cite_ref-2\"></sup>​Como el consumo de energ&iacute;a y por consiguiente la generaci&oacute;n de calor de las computadoras constituye una preocupaci&oacute;n en los &uacute;ltimos a&ntilde;os,<sup id=\"cite_ref-4\"></sup>​ la computaci&oacute;n en paralelo se ha convertido en el paradigma dominante en la&nbsp;arquitectura de computadores, principalmente en forma de&nbsp;procesadores multin&uacute;cleo.<sup id=\"cite_ref-6\"></sup></p>\n<h2>Computaci&oacute;n Ubicua</h2>\n<p>La Computaci&oacute;n Ubicua, tambi&eacute;n denominada Computaci&oacute;n Pervasiva, fue descrita por primera vez por Mark Weiser en 1991. La esencia de su visi&oacute;n era la creaci&oacute;n de entornos repletos de computaci&oacute;n y capacidad de comunicaci&oacute;n, integrados de forma inapreciable con las personas. En la fecha en que Weiser describi&oacute; su idea no exist&iacute;a la tecnolog&iacute;a necesaria para llevarla a cabo, por lo que no era posible desarrollarla, pero despu&eacute;s de una d&eacute;cada de progreso, estas ideas son productos comercialmente viables, a&uacute;n cuando fueron en sus or&iacute;genes criticadas.</p>\n<p>Uno de los objetivos m&aacute;s importantes de la Computaci&oacute;n Ubicua es integrar los dispositivos computacionales lo m&aacute;s posible, como se puede ver en la figura, para hacer que se mezclen en la vida cotidiana, y permitir a los usuarios que se centren en las tareas que deben hacer, no en las herramientas que deben usar, pudiendo suponer una revoluci&oacute;n que cambie el modo de vida. El hecho de enviar la computaci&oacute;n a un &ldquo;segundo plano&rdquo; tiene dos significados:</p>\n<ul>\n<li>El primero es el significado literal, detallando que la tecnolog&iacute;a de la computaci&oacute;n se debe integrar en los objetos, cosas, tareas y entornos cotidianos.<!--[endif]--></li>\n<li>El segundo se refiere a que esta integraci&oacute;n se debe realizar de forma que estos elementos no deben interferir en las actividades para las que son usadas, proporcionando un uso m&aacute;s c&oacute;modo, sencillo y &uacute;til de los mismos.</li>\n</ul>\n<p><img src=\"https://lh6.googleusercontent.com/proxy/2U5z_l7Sdju_hTvb1kj2wo0sAnPrrb6UT8Yi0akgkE9kMpPlgssGVCJ88KeqfMKRASboJ3S_nPGZvlNwrq4YypUWkuwXLowqD67xbYBEEw=s0-d\" alt=\"\" width=\"512\" height=\"384\"></p>\n<p>Por tanto, los objetos cotidianos en los que se integra la tecnolog&iacute;a de computaci&oacute;n, tienen una serie de caracter&iacute;sticas que permiten y delimitan la creaci&oacute;n del entorno ubicuo buscado: Comunicaci&oacute;n entre dispositivos, ya que los elementos del sistema disponen no s&oacute;lo de capacidad de computaci&oacute;n, sino tambi&eacute;n de comunicaci&oacute;n, tanto con el usuario como con los dem&aacute;s elementos a su alrededor mediante WiFi, Bluetooth, GPRS/UMTS, UWB, RFID, etc.</p>\n<h3>Caracteristicas de computaci&oacute;n ubicua</h3>\n<ul>\n<li>Uso eficaz de espacios \"perspicaces\": Se basa, en la detecci&oacute;n del estado de un individuo y de sus necesidades, deducidas de dicho estado, ya sea en la oficina, sala de reuniones, clase, domicilio, coche, etc. El espacio perspicaz surge cuando varios dispositivos inteligentes coinciden en el mismo espacio f&iacute;sico e interact&uacute;an colaborativamente para dar soporte a los individuos que se encuentren en &eacute;l. La dom&oacute;tica, computaci&oacute;n ubicua en el domicilio, es la aplicaci&oacute;n m&aacute;s popular. &nbsp;</li>\n<li>Invisibilidad: Actualmente, se est&aacute; lejos de la propiedad expuesta por Weiser para los sistemas ubicuos, la completa desaparici&oacute;n de la tecnolog&iacute;a de la consciencia del usuario. Una buena aproximaci&oacute;n es tener presente, en el dise&ntilde;o de estos sistemas, la idea de m&iacute;nima distracci&oacute;n del usuario. La invisibilidad va a requerir del cambio dr&aacute;stico en el tipo de interfaces que nos comunican con los computadores. Reconocimiento de voz y de gestos, comprensi&oacute;n del lenguaje natural y del texto manuscrito, en la direcci&oacute;n hombre‐m&aacute;quina y en el sentido contrario, s&iacute;ntesis de lenguaje hablado y escrito y de representaciones gr&aacute;ficas. &nbsp;</li>\n<li>Escalabilidad local: El concepto de localidad de servicios en computaci&oacute;n ubicua es fundamental frente a la universalidad de servicios de Internet. Los usuarios disponen de capacidades asociadas al contexto en el que se encuentran, careciendo de sentido, por ejemplo, que las aplicaciones dom&oacute;ticas situadas en el domicilio particular tengan que estar escrutando las necesidades del usuario que se encuentra trabajando en ese momento en la oficina. Al igual que la mayor&iacute;a de las interacciones en la naturaleza, la proporcionada por estos sistemas, decrece con la distancia al usuario. &nbsp;</li>\n<li>Ocultaci&oacute;n de los desniveles de acondicionamiento: Dependiendo de la infraestructura y del desarrollo tecnol&oacute;gico disponible, la distribuci&oacute;n de los servicios ofrecidos puede ser muy poco uniforme, en esta situaci&oacute;n el principio de invisibilidad puede no cumplirse ya que el usuario detectar&iacute;a desagradables transiciones. Este requisito es hoy d&iacute;a el m&aacute;s alejado respecto de la situaci&oacute;n ideal, los sistemas que incorporan computaci&oacute;n ubicua est&aacute;n aislados, sin continuidad entre unos y otros.&nbsp;</li>\n</ul>\n<h3>Aplicaciones de la computaci&oacute;n ubicua</h3>\n<p>La Computaci&oacute;n Ubicua permite abarcar muy diversos campos:</p>\n<ul>\n<li>Almacenamiento de informaci&oacute;n</li>\n<li>Visualizaci&oacute;n de informaci&oacute;n</li>\n<li>Simulaci&oacute;n y realidad aumentada</li>\n<li>Construcci&oacute;n y modelado</li>\n<li>Gesti&oacute;n, configuraci&oacute;n y control de sistemas complejos</li>\n<li>Educaci&oacute;n</li>\n<li>Sistemas de programaci&oacute;n basados en el uso de objetos f&iacute;sicos para la codificaci&oacute;n de los algoritmos</li>\n<li>Trabajo colaborativo</li>\n<li>Entretenimiento</li>\n</ul>","date":"2022-05-20","autor":"","id":1012},
    {"title":"El paradigma Cliente/Servidor","content":"<h1 style=\"text-align: justify;\">El paradigma Cliente/Servidor</h1>\n<h2 style=\"text-align: justify;\">Definici&oacute;n de cliente y servidor</h2>\n<p style=\"text-align: justify;\"><img src=\"https://upload.wikimedia.org/wikipedia/commons/1/1c/Cliente-Servidor.png\" alt=\"\" width=\"461\" height=\"222\"></p>\n<h3 style=\"text-align: justify;\">Cliente</h3>\n<p style=\"text-align: justify;\">Es el que inicia un requerimiento de servicio. El requerimiento inicial puede convertirse en m&uacute;ltiples requerimientos de trabajo a trav&eacute;s de redes LAN o WAN. La ubicaci&oacute;n de los datos o de las aplicaciones es totalmente transparente para el cliente.</p>\n<h3 style=\"text-align: justify;\">Servidor</h3>\n<p style=\"text-align: justify;\">Es cualquier recurso de c&oacute;mputo dedicado a responder a los requerimientos del cliente. Los servidores pueden estar conectados a los clientes a trav&eacute;s de redes LANs o WANs, para proveer de m&uacute;ltiples servicios a los clientes y ciudadanos tales como impresi&oacute;n, acceso a bases de datos, fax, procesamiento de im&aacute;genes, etc.&nbsp;</p>\n<h2 style=\"text-align: justify;\">Definici&oacute;n del modelo cliente/servidor</h2>\n<p style=\"text-align: justify;\">El modelo Cliente/Servidor es un modelo de aplicaci&oacute;n distribuida en el que las tareas se reparten entre los proveedores de recursos o servicios, llamados servidores, y los demandantes, llamados clientes. Las aplicaciones Clientes realizan peticiones a una o varias aplicaciones Servidores, que deben encontrarse en ejecuci&oacute;n para atender dichas demandas.</p>\n<p style=\"text-align: justify;\">El modelo Cliente/Servidor permite diversificar el trabajo que realiza cada aplicaci&oacute;n, de forma que los Clientes no se sobrecarguen, cosa que ocurrir&iacute;a si ellos mismos desempe&ntilde;an las funciones que le son proporcionadas de forma directa y transparente. En esta arquitectura la capacidad de proceso est&aacute; repartida entre los clientes y los servidores, aunque son m&aacute;s importantes las ventajas de tipo organizativo debidas a la centralizaci&oacute;n de la gesti&oacute;n de la informaci&oacute;n y la separaci&oacute;n de responsabilidades, lo que facilita y clarifica el dise&ntilde;o del sistema. Tanto el Cliente como el Servidor son entidades abstractas que pueden residir en la misma m&aacute;quina o en m&aacute;quinas diferentes.</p>\n<p style=\"text-align: justify;\">Una disposici&oacute;n muy com&uacute;n son los sistemas multicapa en los que el servidor se descompone en diferentes programas que pueden ser ejecutados por diferentes computadoras aumentando as&iacute; el grado de distribuci&oacute;n del sistema.</p>\n<h2 style=\"text-align: justify;\">Modelo de servicios</h2>\n<p style=\"text-align: justify;\">Un modelo es una vista abstracta que establece las definiciones, reglas y relaciones entre las estructuras relacionadas con la aplicaci&oacute;n. Sirve de base para el intercambio de ideas durante el desarrollo l&oacute;gico de la aplicaci&oacute;n y determina c&oacute;mo ser&aacute; la aplicaci&oacute;n resultante.</p>\n<p style=\"text-align: justify;\">Tomemos el ejemplo de de una casa, autom&aacute;ticamente se asume que &eacute;sta tendr&aacute; un sal&oacute;n, habitaciones, ba&ntilde;os, cocina, etc., sin que se nos diga nada m&aacute;s. Aunque la casa no tuviera sal&oacute;n, el modelo nos servir&iacute;a como punto de partida para \"entender\" el concepto \"casa\" y empezar a discutir sobre ella. De igual manera, el modelo de una aplicaci&oacute;n nos indica lo que hace una aplicaci&oacute;n o m&aacute;s exactamente, lo que uno cree que debe hacer la aplicaci&oacute;n.</p>\n<p style=\"text-align: justify;\">El modelo de servicios establece tres grandes conjuntos de funcionalidades, en cada uno de los cuales se encuadran las distintas tareas en las que se ve involucrado cualquier tipo de proyecto de desarrollo. Dicho modelo establece los siguientes conjuntos que com&uacute;nmente denominamos l&oacute;gicas, las cuales son:</p>\n<ul style=\"text-align: justify;\">\n<li>L&oacute;gica de presentaci&oacute;n</li>\n<li>L&oacute;gica de negocio</li>\n<li>L&oacute;gica de datos</li>\n</ul>\n<h3 style=\"text-align: justify;\">L&oacute;gica de presentaci&oacute;n</h3>\n<p style=\"text-align: justify;\">Esta l&oacute;gica es la responsable del control de todos los aspectos relacionados con la interacci&oacute;n entre el usuario y la aplicaci&oacute;n. Para llevar a cabo esta tarea de control, es necesario conocer qu&eacute; tipos de usuarios utilizar&aacute;n la aplicaci&oacute;n, qu&eacute; actividades tienen que realizar y, teniendo en cuenta estos datos, cu&aacute;les son los mejores estilos de interfaz para que esos usuarios realicen sus tareas. En esta l&oacute;gica se engloban todas las tareas que deben ser realizadas por la parte Cliente del modelo general.</p>\n<p style=\"text-align: justify;\">Con el fin de independizar (en la medida de lo posible) la interfaz de usuario de las caracter&iacute;sticas propias de los procesos, debemos tener presente que la codificaci&oacute;n de las tareas asociadas a esta l&oacute;gica consiste, principalmente, en la llamada a procesos independientes situados en las otras l&oacute;gicas, cuya ejecuci&oacute;n es totalmente transparente. Si en la capa que implementa la l&oacute;gica de presentaci&oacute;n no incluimos l&oacute;gica del negocio ni accesos directos a datos, conseguiremos que esta capa sea inmune a los cambios introducidos en los procedimientos de la empresa, as&iacute; como a los cambios de los sistemas de gesti&oacute;n de datos utilizados.</p>\n<h3 style=\"text-align: justify;\">L&oacute;gica de Negocio</h3>\n<p style=\"text-align: justify;\">Es la l&oacute;gica de la aplicaci&oacute;n que controla la secuencia de acciones y fuerza el cumplimiento de las reglas del negocio propias de cada empresa; adem&aacute;s, asegura la integridad de las transacciones de las operaciones necesarias que haya que realizar para que se cumplan dichas reglas. La l&oacute;gica del negocio tambi&eacute;n transforma una serie de datos en informaci&oacute;n &uacute;til para el usuario mediante la aplicaci&oacute;n de las reglas apropiadas.</p>\n<p style=\"text-align: justify;\">El objetivo que debe cumplir esta l&oacute;gica es el de aislar las reglas del negocio, as&iacute; como las transformaciones de datos de los consumidores (usuarios y otros componentes de esta misma capa) y de los sistemas de gesti&oacute;n de datos. Este aislamiento tiene las siguientes ventajas:&nbsp;</p>\n<ul style=\"text-align: justify;\">\n<li>Flexibilidad a la hora de decidir c&oacute;mo y d&oacute;nde situar el c&oacute;digo de esta l&oacute;gica: en componentes dentro de una aplicaci&oacute;n servidora; en procedimientos almacenados, dentro del sistema gestor de datos; o incluso en el cliente.</li>\n<li>La habilidad de colocar distintas interfaces de usuario para un mismo conjunto est&aacute;ndar de reglas de negocio. Por ejemplo, el conjunto de reglas que define las operaciones realizables con los clientes puede implementarse como un solo componente que se ejecuta en un servidor. Los servicios que ofrece este componente pueden utilizarse desde una macro que se ejecute dentro de Microsoft Office, desde una aplicaci&oacute;n desarrollada con Visual Basic o desde p&aacute;ginas HTML vistas desde Internet Explorer.</li>\n<li>Facilita el mantenimiento de las reglas del negocio y de su l&oacute;gica, aislando los cambios de las interfaces de los usuarios y de los datos.</li>\n<li>La habilidad para sustituir el c&oacute;digo de estas reglas, de forma que, aunque el conjunto de reglas que se encuentra dentro de un conjunto de servicios del negocio var&iacute;a de un pa&iacute;s a otro, las interfaces de esos servicios pueden permanecer constantes.</li>\n</ul>\n<h3 style=\"text-align: justify;\">L&oacute;gica de Datos</h3>\n<p style=\"text-align: justify;\">En este conjunto entran los procesos encargados de la gesti&oacute;n de los datos propiamente dicha, es decir, los procesos encargados del mantenimiento de los datos, de garantizar las reglas de integridad referencial establecidas, as&iacute; como de la gesti&oacute;n de las transacciones. Estas tareas son realizadas, generalmente, por un Sistema de Gesti&oacute;n de Bases de Datos Relacionales, como SQL Server, Oracle, MySQL, Informix, etc.</p>\n<h2 style=\"text-align: justify;\">Modelo Cliente/Servidor 2 capas</h2>\n<p style=\"text-align: justify;\">Uno de los objetivos de las aplicaciones de 2 capas es separar la l&oacute;gica de acceso a los datos de lo que es la interfaz de usuario y trasladarla al servidor. Habitualmente, se implementan servicios como procedimientos almacenados en el sistema gestor de datos; con esto se pretende reducir la carga de los clientes y centralizar las operaciones comunes de acceso a los datos. El Sistema Gestor de Datos tambi&eacute;n suele incorporar la funcionalidad necesaria para trabajar en entornos multiusuarios.</p>\n<p style=\"text-align: justify;\">En este modelo intervienen &uacute;nicamente dos entidades: El Cliente y El Servidor.</p>\n<p style=\"text-align: justify;\">El papel de Cliente lo desempe&ntilde;a la aplicaci&oacute;n final del usuario, que implementar&aacute; todas las funciones correspondientes a la l&oacute;gica de presentaci&oacute;n, m&aacute;s algunas de las funciones relacionadas con la l&oacute;gica del negocio, como pueden ser determinadas validaciones de datos y condiciones de recuperaci&oacute;n.</p>\n<p style=\"text-align: justify;\">El papel de Servidor lo desempe&ntilde;a el propio SGBD, el cual se ocupar&aacute; de todas las funciones correspondientes a la l&oacute;gica de datos, m&aacute;s las restantes funciones correspondientes a la l&oacute;gica del negocio, mediante la codificaci&oacute;n de Procedimientos Almacenados.</p>\n<p style=\"text-align: justify;\">Este es el modelo C/S m&aacute;s sencillo y m&aacute;s utilizado habitualmente. En la mayor parte de los casos, el desarrollador de una aplicaci&oacute;n de este tipo, desarrolla &uacute;nicamente la aplicaci&oacute;n Cliente y utiliza al propio motor de BD como aplicaci&oacute;n servidora, de modo que no se codifica la aplicaci&oacute;n Servidora propiamente dicha.</p>\n<p style=\"text-align: justify;\"><img src=\"https://www.monografias.com/trabajos89/cliente-servidor-dos-capas/image001.gif\" alt=\"Cliente Servidor de dos capas\"></p>\n<h2 style=\"text-align: justify;\">Modelo Cliente/Servidor multicapa</h2>\n<p style=\"text-align: justify;\">La arquitectura cliente/servidor gen&eacute;rico tiene dos tipos de nodos en la red: clientes y servidores. Consecuentemente, estas arquitecturas gen&eacute;ricas se refieren a veces como arquitecturas de dos niveles o dos capas.</p>\n<p style=\"text-align: justify;\">Algunas redes disponen de tres tipos de nodos:</p>\n<ul style=\"text-align: justify;\">\n<li>Clientes que interact&uacute;an con los usuarios finales.</li>\n<li>Servidores de aplicaci&oacute;n que procesan los datos para los clientes.</li>\n<li>Servidores de la base de datos que almacenan los datos para los servidores de aplicaci&oacute;n.</li>\n</ul>\n<p style=\"text-align: justify;\">Esta configuraci&oacute;n se llama una arquitectura de tres capas.</p>\n<p style=\"text-align: justify;\">Este modelo aporta una flexibilidad adicional en la construcci&oacute;n de aplicaciones cuando &eacute;stas aumentan su complejidad. Influye tanto en el modelo de aplicaci&oacute;n (l&oacute;gicas de presentaci&oacute;n, del negocio y de datos) como en la distribuci&oacute;n de los servicios. El modelo conceptual de una aplicaci&oacute;n establece sus definiciones, reglas y relaciones as&iacute; como su estructura. Hay partes de la l&oacute;gica que residen en el cliente, normalmente las que se refieren a la interfaz de usuario, mientras que las del negocio y de datos suelen residir en los servidores, que proporcionan los mecanismos necesarios para el trabajo en entornos multiusuarios. En este tipo de modelo se aplica &iacute;ntegramente el modelo de servicios ya que, cada una de las capas se corresponde con cada una de las l&oacute;gicas descritas.</p>\n<p style=\"text-align: justify;\">En la actualidad las t&eacute;cnicas y lenguajes de programaci&oacute;n de servidores han avanzado de tal forma de permitir desarrollos modulares (por ejemplo mediante la arquitectura MVC, Model&shy;Control&shy;View), orientaci&oacute;n a objetos y existen innumerables frameworks y librer&iacute;as para simplificar la tarea de los desarrolladores de software. Una de las caracter&iacute;sticas principales de este modelo reside en la desconexi&oacute;n total entre la l&oacute;gica de presentaci&oacute;n y la l&oacute;gica de los datos. Las conexiones que se producen, se dan entre las l&oacute;gicas de presentaci&oacute;n y del negocio, y las l&oacute;gicas del negocio y la de datos.</p>\n<p style=\"text-align: justify;\">Este modelo hace que la aplicaci&oacute;n final sea completamente independiente del origen de los datos que procesa, tarea que pasa a ser competencia directa del componente especializado.</p>\n<p style=\"text-align: justify;\">A pesar de esto, no es necesario que las distintas l&oacute;gicas residan en m&aacute;quinas diferentes; en la mayor&iacute;a de los casos, es perfectamente compatible su implementaci&oacute;n en la misma m&aacute;quina, si bien este dise&ntilde;o no es el m&aacute;s habitual.</p>\n<p style=\"text-align: justify;\"><img src=\"https://upload.wikimedia.org/wikipedia/commons/e/ea/Tres_capas.PNG\" alt=\"Programaci&oacute;n por capas - Wikipedia, la enciclopedia libre\"></p>","date":"2022-05-27","autor":"","id":16154}
    

  ]

  constructor() {

  }

  getBlogs() {
    return this.blogs_json;
  }

  getBlog(id: number) {
    //return this.blogs.find(blog => blog.id === id);
  }

  //make a json file
  generateBlog(title: string, content: string, date: any, autor: string) {
    let json = {
      title: title,
      content: content,
      date: date,
      autor: autor,
      id: this.getRandomInt(100000)
    }

    this.blogs.push(json);
  }

  //getBlogBylastDate
  getBlogByLastDate() {
    return this.blogs.sort((a, b) => {
      return new Date(b.date).getTime() - new Date(a.date).getTime();
    });
  }

  getRandomInt(arg0: number) {
    return Math.floor(Math.random() * Math.floor(arg0));
  }

}
